<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DM Chat</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
</head>
<body>
  <div class="app">
    <!-- header -->
    <div class="header">
      <div class="avatar"></div>
      <div class="who">
        <div class="name">Private Chat</div>
        <div class="online" id="onlineText">Online</div>
      </div>
    </div>

    <!-- messages -->
    <div id="messages" class="messages"></div>

    <!-- input bar -->
    <div class="inputbar">
      <input id="input" placeholder="Message..." autocomplete="off" />
      <button id="sendBtn">Send</button>
    </div>
  </div>

<script>
  // --- socket setup
  const socket = io();

  // --- DOM
  const listEl = document.getElementById('messages');
  const inputEl = document.getElementById('input');
  const sendBtn = document.getElementById('sendBtn');
  const onlineText = document.getElementById('onlineText');

  // helpers
  const clientId = () => 'c_' + Date.now().toString(36) + '_' + Math.random().toString(36).slice(2,8);
  const localTime = () => {
    const d = new Date();
    return d.getHours().toString().padStart(2,'0') + ':' + d.getMinutes().toString().padStart(2,'0');
  };
  const isEmojiOnly = (t) => {
    const s = (t||'').trim();
    try { return /^[\p{Emoji}\u200d]+$/u.test(s); } catch { return s.length<=2; }
  };

  // keep map to replace temp -> server id
  const tempMap = {}; // client_id -> tempElementId

  // render one bubble
  function renderBubble({id, text, time, status}, side){
    // side: 'self' or 'other'
    const div = document.createElement('div');
    div.className = `row ${side}`;
    div.id = id ? ('msg-'+id) : '';
    const emojiClass = isEmojiOnly(text) ? 'emoji' : '';
    div.innerHTML = `
      <div class="bubble ${side==='self'?'self':'other'} ${emojiClass}">
        <span class="content">${escapeHtml(text)}</span>
        <span class="meta">
          <span class="t">${time||''}</span>
          ${side==='self' ? `<span class="ticks">${statusToTicks(status)}</span>` : ''}
        </span>
      </div>
    `;
    listEl.appendChild(div);
    listEl.scrollTop = listEl.scrollHeight;
    return div;
  }

  function escapeHtml(s){ return (s||'').replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;'); }
  function statusToTicks(s){
    if(s==='read') return '<span class="tick read">✓✓</span>';
    if(s==='delivered') return '✓✓';
    return '✓';
  }

  // presence
  socket.on('presence', ({online})=>{
    onlineText.textContent = online>1 ? 'Online • ' + online : 'Online';
  });

  // history on join
  socket.on('chat_history', (arr)=>{
    listEl.innerHTML = '';
    // show oldest first
    arr.forEach(m => renderBubble(m, 'other')); // history has no "me" concept; all as "other"
    listEl.scrollTop = listEl.scrollHeight;
  });

  // new message from others
  socket.on('receive_message', (m)=>{
    // avoid duplicate
    if(document.getElementById('msg-'+m.id)) return;
    renderBubble(m, 'other');
    // mark as read quickly (simulate viewing)
    setTimeout(()=> socket.emit('message_read', {id: m.id}), 500);
  });

  // status updates (delivered mapping + read)
  socket.on('status_update', (u)=>{
    // mapping for sender
    if(u.client_id && u.server_id && u.status==='delivered'){
      const tempId = tempMap[u.client_id];
      if(tempId){
        const el = document.getElementById(tempId);
        if(el){
          el.id = 'msg-'+u.server_id;               // swap to real id
          const ticks = el.querySelector('.ticks');
          if(ticks) ticks.innerHTML = statusToTicks('delivered');
        }
        delete tempMap[u.client_id];
      }
      return;
    }
    // later read updates
    if(u.server_id && u.status){
      const el = document.getElementById('msg-'+u.server_id);
      if(el){
        const ticks = el.querySelector('.ticks');
        if(ticks) ticks.innerHTML = statusToTicks(u.status);
      }
    }
  });

  // send flow
  function doSend(){
    const text = inputEl.value.trim();
    if(!text) return;

    const cid = clientId();
    const time = localTime();
    const tempElId = 'temp-'+cid;

    // optimistic bubble (right side)
    const tempDiv = renderBubble({id:null, text, time, status:'sent'}, 'self');
    tempDiv.id = tempElId;
    tempMap[cid] = tempElId;

    // send to server
    socket.emit('send_message', { client_id: cid, text, time });
    inputEl.value = '';
  }

  sendBtn.onclick = doSend;
  inputEl.addEventListener('keydown', e=>{ if(e.key==='Enter') doSend(); });

  // mobile keyboard adjustments
  window.addEventListener('resize', ()=>{
    listEl.scrollTop = listEl.scrollHeight;
  });
</script>
</body>
</html>
