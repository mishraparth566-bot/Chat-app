<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Messenger</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
</head>
<body>
  <div class="chat-shell">
    <header class="chat-header">
      <div class="header-left">
        <button class="icon back" aria-label="Back">◀</button>
        <div class="chat-title">Messages</div>
      </div>
      <div class="header-right">
        <div id="onlineBadge" class="online hidden">Online</div>
      </div>
    </header>

    <main class="chat-area">
      <div id="messages" class="messages"></div>

      <!-- typing indicator (optional; shown only if you later emit typing events) -->
      <div id="typingIndicator" class="typing hidden">
        <span></span><span></span><span></span>
      </div>
    </main>

    <!-- input / composer fixed at the bottom -->
    <form id="inputForm" class="input-form" action="javascript:void(0);">
      <div class="input-wrapper">
        <input id="messageInput" type="text" autocomplete="off" placeholder="iMessage..." />
      </div>
      <button id="sendBtn" type="submit" class="send-btn" aria-label="Send">➤</button>
    </form>
  </div>

  <script>
    // ---------- Setup ----------
    const socket = io();
    const messagesEl = document.getElementById('messages');
    const messageInput = document.getElementById('messageInput');
    const inputForm = document.getElementById('inputForm');
    const onlineBadge = document.getElementById('onlineBadge');

    // Persisted client id to align "mine" messages across refresh
    let clientId = localStorage.getItem('client_id');
    if (!clientId) {
      clientId = 'c_' + Date.now() + '_' + Math.random().toString(36).slice(2,9);
      localStorage.setItem('client_id', clientId);
    }

    // Join with client_id so server can count unique online users
    socket.on('connect', () => {
      socket.emit('join', { client_id: clientId });
    });

    // ---------- Helpers ----------
    function isOnlyEmoji(str) {
      const s = (str || '').trim();
      if (!s) return false;
      try {
        // Emoji presentation / compound emojis supported
        const re = /^(?:\p{Extended_Pictographic}|\p{Emoji_Presentation}|\p{Emoji}\uFE0F|\p{Emoji_Modifier_Base}|\u200D)+$/u;
        return re.test(s);
      } catch (e) {
        // Fallback: check if all chars are non-alphanumeric
        return /^[^\w]+$/.test(s);
      }
    }

    function formatTime(ts) {
      try {
        return new Date(ts * 1000).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      } catch {
        return '';
      }
    }

    function scrollToBottom() {
      requestAnimationFrame(() => {
        messagesEl.scrollTop = messagesEl.scrollHeight;
      });
    }

    // ---------- Rendering ----------
    function renderMessage(msg) {
      const mine = msg.client_id === clientId;
      const bubble = document.createElement('div');
      bubble.className = `msg-bubble ${mine ? 'mine' : 'theirs'}`;
      bubble.dataset.id = msg.id;

      // text
      const textEl = document.createElement('div');
      textEl.className = isOnlyEmoji(msg.text) ? 'msg-text emoji-standalone' : 'msg-text';
      textEl.textContent = msg.text;

      // meta (time + receipts for my messages)
      const meta = document.createElement('div');
      meta.className = 'meta';

      const timeEl = document.createElement('span');
      timeEl.className = 'time';
      timeEl.textContent = formatTime(msg.timestamp);
      meta.appendChild(timeEl);

      if (mine) {
        const statusEl = document.createElement('span');
        statusEl.className = 'status';
        if (msg.status === 'read') {
          statusEl.innerHTML = '<span class="check-blue">✓✓</span>';
        } else if (msg.status === 'received') {
          statusEl.textContent = '✓✓';
        } else {
          statusEl.textContent = '✓';
        }
        meta.appendChild(statusEl);
      }

      bubble.appendChild(textEl);
      bubble.appendChild(meta);
      messagesEl.appendChild(bubble);
    }

    // ---------- Load history ----------
    socket.on('chat_history', (history) => {
      messagesEl.innerHTML = '';
      history.forEach(renderMessage);
      scrollToBottom();
    });

    // ---------- Online badge ----------
    socket.on('online_count', ({ online }) => {
      if (online > 1) onlineBadge.classList.remove('hidden');
      else onlineBadge.classList.add('hidden');
    });

    // ---------- Send message ----------
    inputForm.addEventListener('submit', (e) => {
      e.preventDefault();
      const text = messageInput.value.trim();
      if (!text) return;
      socket.emit('send_message', { client_id: clientId, text });
      messageInput.value = '';
    });

    // ---------- Receive new message ----------
    socket.on('new_message', (msg) => {
      renderMessage(msg);
      scrollToBottom();

      // Delivery + read acknowledgements for messages not mine
      if (msg.client_id !== clientId) {
        // Mark delivered as soon as received
        socket.emit('message_received', { message_id: msg.id });

        // Auto-mark read when message is scrolled into view or after a small delay.
        // For a simple room, we mark read after a short delay.
        setTimeout(() => {
          socket.emit('message_read', { message_id: msg.id });
        }, 800);
      }
    });

    // ---------- Update message status (✓ / ✓✓ gray / ✓✓ blue) ----------
    socket.on('message_status', ({ message_id, status }) => {
      const bubble = messagesEl.querySelector(`.msg-bubble[data-id="${message_id}"]`);
      if (!bubble) return;
      const statusEl = bubble.querySelector('.status');
      if (!statusEl) return;
      if (status === 'read') {
        statusEl.innerHTML = '<span class="check-blue">✓✓</span>';
      } else if (status === 'received') {
        statusEl.textContent = '✓✓';
        statusEl.classList.remove('check-blue');
      } else {
        statusEl.textContent = '✓';
        statusEl.classList.remove('check-blue');
      }
    });

    // ---------- Mobile keyboard adaptation ----------
    // Keep the composer pinned above the keyboard on mobile
    function setBodyHeight() {
      document.body.style.height = window.innerHeight + 'px';
    }
    window.addEventListener('resize', () => {
      setBodyHeight();
      scrollToBottom();
    });
    window.addEventListener('load', () => {
      setBodyHeight();
      setTimeout(scrollToBottom, 50);
    });
  </script>
</body>
</html>
